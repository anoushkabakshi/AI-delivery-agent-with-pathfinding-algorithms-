"""
Autonomous delivery agent that uses different search strategies.
"""

import time
from typing import List, Tuple, Dict
from .search_algorithms import SearchAlgorithms, SearchResult

class DeliveryAgent:
    def __init__(self, grid):
        self.grid = grid
        self.position = grid.start
        self.path = []
        self.current_time = 0
        self.total_cost = 0
        self.search_algorithms = SearchAlgorithms(grid)
        self.log = []
        self.movement_history = [grid.start]
    
    def plan_path(self, algorithm: str, start: Tuple[int, int] = None, 
                 goal: Tuple[int, int] = None, time_step: int = 0) -> SearchResult:
        """Plan a path using the specified algorithm."""
        if start is None:
            start = self.position
        if goal is None:
            goal = self.grid.goal
        
        self.log.append(f"Time {self.current_time}: Planning path from {start} to {goal} using {algorithm}")
        
        if algorithm == "bfs":
            result = self.search_algorithms.bfs(start, goal, time_step)
        elif algorithm == "ucs":
            result = self.search_algorithms.uniform_cost_search(start, goal, time_step)
        elif algorithm == "astar":
            result = self.search_algorithms.a_star(start, goal, time_step)
        elif algorithm == "hillclimb":
            result = self.search_algorithms.hill_climbing(start, goal, time_step=time_step)
        else:
            raise ValueError(f"Unknown algorithm: {algorithm}")
        
        if result.success:
            self.log.append(f"Path found with cost {result.cost}, nodes expanded: {result.nodes_expanded}")
        else:
            self.log.append(f"Path planning failed! No path found.")
        
        return result
    
    def execute_step(self) -> bool:
        """Execute one step along the current path. Returns True if replanning needed."""
        if not self.path:
            return True  # No path, need to replan
        
        if self.position == self.grid.goal:
            return False  # Already at goal
        
        next_pos = self.path[0]  # Get next position without removing it yet
        
        # Check if next position is blocked by dynamic obstacle
        if self.grid.is_obstacle(next_pos[0], next_pos[1], self.current_time + 1):
            self.log.append(f"Time {self.current_time}: Dynamic obstacle detected at {next_pos}! Replanning needed.")
            return True  # Need to replan
        
        # Move to next position
        self.path.pop(0)  # Remove from path
        move_cost = self.grid.get_cost(next_pos[0], next_pos[1])
        
        self.position = next_pos
        self.total_cost += move_cost
        self.current_time += 1
        self.movement_history.append(self.position)
        
        self.log.append(f"Time {self.current_time}: Moved to {self.position}, cost: {move_cost}, total: {self.total_cost}")
        
        return False  # Continue execution
    
    def deliver_package(self, algorithm: str, max_replans: int = 5, 
                       max_steps: int = 100) -> Dict:
        """Execute the delivery mission with dynamic replanning capability."""
        self.log = []
        self.movement_history = [self.grid.start]
        self.position = self.grid.start
        self.current_time = 0
        self.total_cost = 0
        replan_count = 0
        
        # Initial planning
        result = self.plan_path(algorithm)
        self.path = result.path[1:] if result.path and len(result.path) > 1 else []
        
        metrics = {
            'algorithm': algorithm,
            'success': False,
            'total_cost': 0,
            'total_time': 0,
            'replans': 0,
            'final_path': [],
            'nodes_expanded': result.nodes_expanded,
            'planning_time': result.time_taken,
            'movement_history': []
        }
        
        step_count = 0
        while (self.position != self.grid.goal and 
               step_count < max_steps and 
               replan_count <= max_replans):
            
            step_count += 1
            
            if not self.path:  # No path or path exhausted
                if replan_count >= max_replans:
                    self.log.append("Max replanning attempts reached. Mission failed.")
                    break
                
                replan_count += 1
                self.log.append(f"Replanning attempt {replan_count}")
                result = self.plan_path(algorithm, self.position, self.grid.goal, self.current_time)
                self.path = result.path[1:] if result.path and len(result.path) > 1 else []
                metrics['nodes_expanded'] += result.nodes_expanded
                metrics['planning_time'] += result.time_taken
                metrics['replans'] = replan_count
                
                if not result.success:
                    self.log.append("Replanning failed! Mission aborted.")
                    break
            
            need_replan = self.execute_step()
            if need_replan:
                self.path = []  # Force replanning on next iteration
        
        if self.position == self.grid.goal:
            metrics['success'] = True
            metrics['total_cost'] = self.total_cost
            metrics['total_time'] = self.current_time
            metrics['final_path'] = self.movement_history
            metrics['movement_history'] = self.movement_history
            self.log.append(f"Delivery successful! Total cost: {self.total_cost}, Time: {self.current_time}")
        else:
            metrics['final_path'] = self.movement_history
            metrics['movement_history'] = self.movement_history
            self.log.append(f"Delivery failed! Final position: {self.position}")
        
        return metrics
    
    def get_path_taken(self) -> List[Tuple[int, int]]:
        """Get the actual path taken by the agent."""
        return self.movement_history
    
    def print_log(self):
        """Print the execution log."""
        for entry in self.log:
            print(entry)
    
    def get_status(self) -> Dict:
        """Get current agent status."""
        return {
            'position': self.position,
            'time': self.current_time,
            'total_cost': self.total_cost,
            'path_remaining': len(self.path),
            'at_goal': self.position == self.grid.goal
        }


# Test the delivery agent
if __name__ == "__main__":
    from grid import Grid
    
    # Create a test grid
    grid = Grid(5, 5)
    grid.add_static_obstacle(2, 2)
    grid.set_terrain_cost(1, 1, 3)
    
    # Test the agent
    agent = DeliveryAgent(grid)
    metrics = agent.deliver_package("astar")
    
    print(f"Mission success: {metrics['success']}")
    print(f"Total cost: {metrics['total_cost']}")
    print(f"Total time: {metrics['total_time']}")
    print(f"Replans: {metrics['replans']}")
    print("\nExecution log:")
    agent.print_log()
